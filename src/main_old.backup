use rayon::iter::*;
use image::*;
use hex::*;
mod parse_text;
use parse_text::*;
use std::io::prelude::*;


fn main() {
    //parse config
    let config_file = file_to_iter(parse_text::open("/Users/yoavnir/Documents/vs code/rust/work in progress/image_to_color_scheme/src/config.txt"));
    let settings : Vec<String> = config_file.lines().map(|x| x.unwrap()).collect();
    let path = settings[0].clone();
    let percent : u8 = settings[3].clone().parse().unwrap();
    let scheme : Vec<[u8;3]> = hexes_to_scheme(settings[6..].to_vec());

    // open image
    let image = image::open(path).unwrap();
    

    // convert image
    let pixels : Vec<[u8;3]>= image.pixels().map(|x| [x.2[0],x.2[1],x.2[2]]).collect();
    let converted : Vec<Rgb<u8>> = pixels.par_iter().map(|x| image::Rgb(pixel_to_scheme(&scheme,x,percent))).collect();
    let mut buffer = RgbImage::new(image.dimensions().0, image.dimensions().1);
    let mut conv_iter = converted.iter();
    for x in 0..image.dimensions().0 {
        for y in 0..image.dimensions().1 {
            buffer.put_pixel(x, y, *conv_iter.next().unwrap())
        }
    }
    buffer.save("converted.png").unwrap();
}

fn pixel_to_scheme(scheme:&Vec<[u8;3]>,pixel:&[u8;3],percent:u8) -> [u8;3] {
    let mut closest = (scheme[0].clone(),distance(&scheme[0],&pixel));
    for color in scheme {
        let current_distance = distance(&color,&pixel);
        if current_distance<closest.1 {
            closest = (color.clone(),current_distance)
        }
    }
    return average(&closest.0,&pixel,percent)
}

fn hexes_to_scheme(hexes:Vec<String>) -> Vec<[u8;3]> {
    let mut res = Vec::new();
    let mut temp_arr = [0_u8;3];
    for hex in hexes {
        decode_to_slice(&hex[1..],&mut temp_arr).unwrap();
        res.push(temp_arr.clone())
    }
    return res
}

fn distance(reference:&[u8;3],pixel:&[u8;3]) -> u8 {
    return ((reference[0] as f64 - pixel[0] as f64).powf(2.0)+
    (reference[1] as f64 - pixel[1] as f64).powf(2.0)+
    (reference[2] as f64 - pixel[2] as f64).powf(2.0))
    .sqrt() as u8
}

fn average(pixel1:&[u8;3],pixel2:&[u8;3],percent:u8) -> [u8;3] {
    let as_dec = percent/100;
    return [pixel1[0]*as_dec+pixel2[0]*(1-as_dec),
            pixel1[1]*as_dec+pixel2[1]*(1-as_dec),
            pixel1[2]*as_dec+pixel2[2]*(1-as_dec)]
}